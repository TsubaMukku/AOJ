/**
 * Tsubasa　Takamuku
 * 2020/03/02 Revised
 * 
 */

**********partitionは何を行う関数か？？？？***

partiton(a, p, r)
  -> a[p,,,,q-1]の各要素が a[q]以下, a[q+1,,,r]の各要素がa[q]より大きい, となるようにaを２つに分割する関数である
  -> index q を戻り値として返す
******************************************



int a[1010101], n;
int func(int p, int r){
    int x, i, j, t;
    
    //partitionの対象範囲はp~rである
    //partitionの基準となる要素はa[r]である
    x = a[r];
    i = p-1;
    
    for (j = p; j < r; j++){
        
        //a[j] > xのときは要素移動なし
        //a[j]をxより大きいグループに含める
        
        //a[j] <= xのときは要素移動が起こる
        if (a[j] <= x){
            
            //基準となるx以下の要素は, [p, i]に存在しなければならない
            i++;
            t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    
    
    //末尾の要素については, 個別に考える必要がある
    i++;
    t = a[i];
    a[i] = a[r];
    a[r] = t;
    
    
    return i;
}




**********quicksortは何を行うアルゴリズムか？？？？***
クイックソートは、適当な値（これを pivot という）を選び、
（１）その pivot よりも大きい値を配列の右側に移動する
（２）pivot よりも小さい値を配列の左側に移動する
これにより, 配列を 2 つに分割する。

次に、分割された 2 つの配列それぞれに対して、pivot を選びさらに分割を行う
分割を再帰的に行なって行ったとき、最終的には整列済みの部分配列が得られる.
  最後にこれらの部分配列を結合すれば、整列済みの配列が得られる。
  
  
クイックソートは、データの比較回数と交換回数が、他のソートアルゴリズムに比べて少ない
値がランダムな配列を整列する場合に、効率が最も良いと言われている。
******************************************


C/C++ でクイックソートを実装する上で、具体的に次のような手順を踏む。

n 個の要素を持つ入力配列 A[1..n] の最後要素を pivot とする。すなわち pivot = A[n] とする
j = 1, 2, ..., i, ..., n-1 それぞれに対して、A[j] と pivot (=A[n]) を比較する
A[j] が大きければ、それを配列の左側の要素を入れ替える。
この入れ替えが終わると、pivot は i の位置に移動する。


位置 i の左側を部分配列として、その部分配列の最後の要素を pivot として、quicksortをおこなう
位置 i の右側を部分配列として、その部分配列の最後の要素を pivot として、quicksortをおこなう


